#lang play

#|
<Src> ::=   <number?>
          | {'+ <Src> <Src>}
          | {'- <Src> <Src>}
          | {'* <Src> ... <Src>}
          | {'- <Src>}

<Expr> ::=   (num <number?>)
           | (add <Expr> <Expr>)
           | (sub <Expr> <Expr>)
           | (mult <list>)
           | (neg <Expr>)
           | (gt <Expr> <Expr>)
           | (lt <Expr> <Expr>)
           | (if-tf <AE> <AE> <AE>)



|#

; subst: ......-> ....

(deftype Expr
  [num n]
  [add l r]
  [sub l r]
  [mult vals]
  [neg n]
  [bool b]
  [if-tf c t f]
  [gt l r]
  [lt l r]
  )

; interp :: Expr -> number?
; evalua una expresion aritmetica.

(define (interp expr)
  (match expr
    [(num n) n]
    [(bool b) b]
    [(add l r) (+ (interp l) (interp r))]
    [(sub l r) (- (interp l) (interp r))]
    [(mult vals) (foldl * 1 (map interp vals))]
    [(neg n) (- (interp n))]
    [(if-tf c t f) (if (interp c) (interp t) (interp f))]
    [(gt l r) (> (interp l) (interp r))]
    [(lt l r) (< (interp l) (interp r))]
  )
)

; parse: Src -> Expr
; parsea codigo fuente
(define (parse src)
  (match src
    [(? number?) (num src)]
    [(? boolean?) (bool src)]
    [(list '+ s1 s2) (add (parse s1) (parse s2))]
    [(list '- s1 s2) (sub (parse s1) (parse s2))]
    [(cons '* vals) (mult (map parse vals))]
    [(list '- s1) (neg (parse s1))]
    [(list 'if-tf cond true-expr false-expr) (if-tf (parse cond) (parse true-expr) (parse false-expr))]
    [(list '> l r) (gt (parse l) (parse r))]
    [(list '< l r) (lt (parse l) (parse r))]
    )
  )
  




; run: Src -> Expr
; corre un programa
(define (run prog)
  (interp (parse prog))
  )

(test (run '{+ 3 4}) 7)
(test (run '{- 5 1}) 4)
(test (run '{- 5 {+ 2 3}}) 0)
(test (run '{- 1}) -1)
(test (run '{- {+ 2 3}}) -5)
(test (run '{* 2 3 4}) 24)

#|

(* 3 2)
(* 1 2 3 4 5)


|#

(test (run '(if-tf #t (+ 1 1) (- 1 1)))2)

(test (run '(if-tf #f (+ 1 1) (- 1 1)))0)

(test (run '(if-tf  (+ 2 3) #t #f))#t)


(test (run '{if-tf (> 1 2) {+ 1 6} {- 1 1}}) 0)
(test (run '{if-tf (< 1 2) {+ 1 6} {- 1 1}}) 7)

(test (run '(> 5 3)) #t)
(test (run '(< 5 3)) #f)



; crear un nuevo let

